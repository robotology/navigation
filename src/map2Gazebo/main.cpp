/*
* Copyright (C) 2006-2018 Istituto Italiano di Tecnologia (IIT)
* All rights reserved.
* Author: Marco Randazzo
* email:  marco.randazzo@iit.it

* This software may be modified and distributed under the terms of the
* BSD-3-Clause license. See the accompanying LICENSE file for details.
*/

/**
 * \section map2Gazebo
 * This module converts a Yarp map into an heightmap which can be imported into gazebo simualtor.
 */

#include <yarp/os/Network.h>
#include <yarp/os/RFModule.h>
#include <yarp/os/Time.h>
#include <yarp/os/Port.h>
#include <yarp/dev/IMap2D.h>
#include <yarp/os/Property.h>
#include <yarp/dev/PolyDriver.h>
#include <yarp/os/LogStream.h>
#include <math.h>
#include <fstream>
#include <string>
#include <iostream>
#include <algorithm>
#include <yarp/sig/ImageFile.h>

using namespace std;
using namespace yarp::os;
using namespace yarp::dev;
using namespace yarp::dev::Nav2D;

YARP_LOG_COMPONENT(MAP2GAZEBO, "navigation.map2Gazebo")

class map2GazeboModule : public yarp::os::RFModule
{
protected:
    Port                         rpcPort;
    PolyDriver                   m_pMap;
    IMap2D*                      m_iMap;
    MapGrid2D                    m_yarp_map;
    double                       m_ceiling;
    double                       m_floor_c;
    bool                         m_crop;
    
    string model_file_string =  "\
    <?xml version=\"1.0\"?> \n \
<model> \n \
    <name>heightmap_model</name>\n \
\
    <version>0.2</version> \n \
    <sdf version='1.6'>output.sdf</sdf>\n \
\
    <author>\n \
        <name>map2Gazebo</name>\n \
        <email>map2Gazebo@iit.it</email>\n \
    </author>\n \
\
    <description>\n \
        Heightmap generated by map2Gazebo\n \
    </description>\n \
</model>\n ";


    string sdf_file_string =  "< ? xml version = \"1.0\" ? > \n \
<sdf version = \"1.5\">  \n \
    <model name = \"heightmap\">  \n \
        <static> true </static>  \n \
        <link name = \"link\">  \n \
\
            <collision name = \"collision\">  \n \
                <geometry> \n \
                    <heightmap> \n \
                        <uri>file://./heightmap.png</uri>  \n \
                        <size> SIZE_XX SIZE_YY SIZE_ZZ </size>  \n \
                        <pos> POS_XX POS_YY POS_ZZ </pos>  \n \
                    </heightmap>  \n \
                </geometry>  \n \
            </collision>  \n \
\
            <visual name = \"visual_abcedf\">  \n \
                <geometry> \n \
                    <heightmap> \n \
                        <use_terrain_paging> false </use_terrain_paging> \n \
\
                        <texture> \n \
                           <diffuse>file://media/materials/textures/grass.jpg</diffuse> \n \
                           <normal>file://media/materials/textures/flat_normal.png</normal> \n \
                           <size> 1 </size> \n \
                        </texture> \n \
                        <texture> \n \
                           <diffuse>file://media/materials/textures/ceiling_tiled.jpg</diffuse> \n \
                           <normal>file://media/materials/textures/flat_normal.png</normal> \n \
                           <size> 1 </size> \n \
                        </texture> \n \
                        <texture> \n \
                           <diffuse>file://media/materials/textures/white.bmp</diffuse> \n \
                           <normal>file://media/materials/textures/flat_normal.png</normal> \n \
                           <size> 1 </size> \n \
                        </texture> \n \
\
                        <blend> \n \
                           <min_height> 0.1 </min_height> \n \
                           <fade_dist> 0 </fade_dist> \n \
                        </blend> \n \
                        <blend> \n \
                           <min_height> 0.7 </min_height> \n \
                           <fade_dist> 0 </fade_dist> \n \
                        </blend> \n \
\
                        <uri>file://./heightmap.png</uri> \n \
                        <size> SIZE_XX SIZE_YY SIZE_ZZ </size>  \n \
                        <pos> POS_XX POS_YY POS_ZZ </pos>  \n \
                    </heightmap> \n \
                </geometry> \n \
            </visual> \n \
\
        </link> \n \
    </model> \n \
</sdf> \n";

public:
    map2GazeboModule()
    {
        m_iMap = nullptr;
        m_ceiling = 3.0; //m
        m_floor_c = 50; //units (0-255)
        m_crop = false;
    }

    void replace(const string& find_str, string& sdf_str, double val)
    {
        size_t pos = sdf_file_string.find(find_str);
        while (pos != std::string::npos)
        {
            sdf_file_string.replace(pos, find_str.size(), std::to_string(val));
            pos = sdf_file_string.find(find_str);
        }
    }

    virtual bool configure(yarp::os::ResourceFinder &rf)
    {
        bool ret = rpcPort.open("/map2Gazebo/rpc");
        if (ret == false)
        {
            yCError(MAP2GAZEBO) << "Unable to open module ports";
            return false;
        }
        attach(rpcPort);
        //attachTerminal();

        if (rf.check("ceiling"))
        {
			m_ceiling = rf.find("ceiling").asDouble();
			yCInfo(MAP2GAZEBO) << "Using ceiling =" << m_ceiling <<"m";
		}
		
		if (rf.check("crop"))
        {
			m_crop = true;
			yCInfo(MAP2GAZEBO) << "crop option enabled";
		}
		
        if (rf.check("from_file"))
        {
            string map_name = rf.find("from_file").asString();
            if (m_yarp_map.loadFromFile(map_name) == false)
            {
                yCError(MAP2GAZEBO) << "Failed to open map: " << map_name;
                return false;
            }
        }
        else if (rf.check("from_server"))
        {
            string map_name = rf.find("from_server").asString();
            //open a client for the server
            Property map_options;
            map_options.put("device", "map2DClient");
            map_options.put("local", "/map2Gazebo"); //This is just a prefix. map2DClient will complete the port name.
            map_options.put("remote", "/mapServer");
            if (m_pMap.open(map_options) == false)
            {
                yCError(MAP2GAZEBO) << "Unable to open mapClient";
                return false;
            }
            m_pMap.view(m_iMap);
            if (m_iMap == 0)
            {
                yCError(MAP2GAZEBO) << "Unable to open map interface";
                return false;
            }

            //get the map from server
            yCInfo(MAP2GAZEBO) << "Asking for map '" << map_name << "'...";
            bool b = m_iMap->get_map(map_name, m_yarp_map);
            if (b)
            {
                yCInfo(MAP2GAZEBO) << "'" << map_name << "' received";
            }
            else
            {
                yCError(MAP2GAZEBO) << "'" << map_name << "' not found";
                return false;
            }
        }
        else
        {
            yCError(MAP2GAZEBO) << "missing options";
            return false;
        }

        double x0=0, y0=0, t0 = 0, r=0;
        size_t w=0, h=0;
        
        m_yarp_map.getOrigin(x0, y0, t0);
        m_yarp_map.getResolution(r);
        m_yarp_map.getSize_in_cells(w,h);
        yCInfo(MAP2GAZEBO) << "Original map size (cells)" << w << "x" << h;
        yCInfo(MAP2GAZEBO) << "Original map size (m)" << w*r << "x" << h*r;
        yCInfo(MAP2GAZEBO) << "Original map origin (m)" << x0 << y0;
        
        if (m_crop)
        {
			yCInfo(MAP2GAZEBO) << "applying crop";
			m_yarp_map.crop(-1, -1, -1, -1);
			m_yarp_map.getOrigin(x0, y0, t0);
            m_yarp_map.getResolution(r);
            m_yarp_map.getSize_in_cells(w,h);
            yCInfo(MAP2GAZEBO) << "Cropped map size (cells)" << w << "x" << h;
            yCInfo(MAP2GAZEBO) << "Cropped map size (m)" << w*r << "x" << h*r;
            yCInfo(MAP2GAZEBO) << "Cropped map origin (m)" << x0 << y0;
		}       

        //heightmaps in gazebo must be square, with size n^2+1. 
        size_t map_size = std::max(w, h);
        map_size--;
        map_size |= map_size >> 1;
        map_size |= map_size >> 2;
        map_size |= map_size >> 4;
        map_size |= map_size >> 8;
        map_size |= map_size >> 16;
        map_size++;
        map_size++;
        yCInfo(MAP2GAZEBO) << "Heightmap size (cells)" << map_size << "x" << map_size;
        yCInfo(MAP2GAZEBO) << "Heightmap size (m)" << map_size*r << "x" << map_size*r;
        double x_off =map_size*r-w*r;
        double y_off =map_size*r-h*r;      
        yCDebug(MAP2GAZEBO) << "Computed offset" << x_off << "," << y_off << "(m)";
        

        //heightmap color code is the following: black=bottom, white=top
        MapGrid2D::map_flags flag;
        XYCell cell;
        yarp::sig::ImageOf<yarp::sig::PixelMono> heightmap;
        heightmap.setQuantum(1);
        heightmap.resize(map_size, map_size);
        
        //prepare an empty heightmap
        for (cell.y = 0; cell.y < map_size; cell.y++)
            for (cell.x = 0; cell.x < map_size; cell.x++)
            {
                heightmap.safePixel(cell.x, cell.y) = 0;
            }
        
        int align = 1;
        yCDebug(MAP2GAZEBO) << "Alignment type:" << align;
        for (cell.y=0; cell.y<h; cell.y++)
            for (cell.x=0; cell.x < w; cell.x++)
            {
                m_yarp_map.getMapFlag(cell, flag);
                size_t computed_x = 0;
                size_t computed_y = 0;
                switch (align)
                {
                     case 0:
                    //align top-left
                    computed_x = cell.x;
                    computed_y = cell.y;
                    break;

                    case 1:
                    default:
                    //align center
                    computed_x = cell.x + (map_size - w) / 2;
                    computed_y = cell.y + (map_size - h) / 2;
                    break;
                }
                switch (flag)
                {
                    case MapGrid2D::map_flags::MAP_CELL_WALL:
                    {
                        heightmap.safePixel(computed_x, computed_y) = 255;
                    } break;
                    case MapGrid2D::map_flags::MAP_CELL_UNKNOWN:
                    {
                        heightmap.safePixel(computed_x, computed_y) = 0;
                    } break;
                    case MapGrid2D::map_flags::MAP_CELL_FREE:
                    default:
                    {
                        heightmap.safePixel(computed_x, computed_y) = m_floor_c;
                    } break;
                }
            }

        //save the heightmap to disk
        yarp::sig::file::write(heightmap, "heightmap.png",yarp::sig::file::FORMAT_PNG);
        yCInfo(MAP2GAZEBO) << "File " << "heightmap.png" << "saved.";

        //process the sdf template
        size_t pos = 0;
        double computed_z = m_floor_c*m_ceiling/255.0; //this brings the free area at zero level
        replace("POS_XX", sdf_file_string, 0); //x0  //x_off
        replace("POS_YY", sdf_file_string, 0); //y0  //y_off
        replace("POS_ZZ", sdf_file_string, -computed_z);
        replace("SIZE_XX", sdf_file_string, w*r);
        replace("SIZE_YY", sdf_file_string, h*r);
        replace("SIZE_ZZ", sdf_file_string, m_ceiling);

        //save the model to disk
        {
			std::ofstream out("model.config");
            out << model_file_string;
            out.close();
            yCInfo(MAP2GAZEBO) << "File "<< "model.config" << "saved.";
	    }

        //save the sdf to disk
        {
			std::ofstream out("output.sdf");
            out << sdf_file_string;
            out.close();
            yCInfo(MAP2GAZEBO) << "File "<< "output.sdf" << "saved.";
        }
        return true;
    }

    virtual bool interruptModule()
    {
        rpcPort.interrupt();
        return true;
    }

    virtual bool close()
    {
        rpcPort.interrupt();
        rpcPort.close();
        return true;
    }

    virtual double getPeriod()
    { 
        return 3.0; 
    }
    
    virtual bool updateModule()
    { 
        return true; 
    }

    virtual bool respond(const yarp::os::Bottle& command,yarp::os::Bottle& reply) 
    {
        reply.clear(); 
        if (command.get(0).isString())
        {
            if (command.get(0).asString()=="quit")
            {
                return false;
            }

            else if (command.get(0).asString()=="help")
            {
                reply.addVocab(Vocab::encode("many"));
                reply.addString("Available commands are:");
                reply.addString("<not yet implemented>");
            }
        }
        else
        {
            yCError(MAP2GAZEBO) << "Invalid command type";
            reply.addString("err");
        }
        return true;
    }
};

int main(int argc, char *argv[])
{
    yarp::os::Network yarp;
    if (!yarp.checkNetwork())
    {
        yCError(MAP2GAZEBO,"check Yarp network.\n");
        return -1;
    }

    yarp::os::ResourceFinder rf;
    rf.setVerbose(true);
    rf.configure(argc,argv);
    std::string debug_rf = rf.toString();

    if (rf.check("help"))
    {
        yCInfo(MAP2GAZEBO) << "Options:";
        yCInfo(MAP2GAZEBO) << "--from_server <map_id>";
        yCInfo(MAP2GAZEBO) << "--from_file <file.map>";
        yCInfo(MAP2GAZEBO) << "--ceiling <meters>";
        yCInfo(MAP2GAZEBO) << "--crop";
        return 0;
    }

    map2GazeboModule theModule;

    return theModule.runModule(rf);
}

 
